;;; eldev.el --- Elisp Development Tool  -*- lexical-binding: t -*-

;;; Copyright (C) 2020 Paul Pogonyshev

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see https://www.gnu.org/licenses.

;;; Code:

(require 'eldev)


;; To silence byte-compilation warnings on Emacs 24-25 and also make code in
;; `eldev-output-reroute-messages' work.
(defvar inhibit-message)

(defvar eldev--active-plugin-documentation nil)


(defun eldev-active-plugins ()
  "Return a list of all activated plugin names.
Since 0.3."
  (mapcar #'car eldev--active-plugin-documentation))

(defun eldev-use-plugin (plugin &rest configuration)
  "Use given PLUGIN in the build.
Currently, only a fixed number of built-in plugins is supported.
In the future, this might become a way to extend Eldev by reusing
third-party code automatically downloaded from a package archive.

CONFIGURATION is specific to each plugin.  Usually it is expected
to be a property list, i.e. keywords interleaved with values.

It is not an error to activate a plugin more than once (e.g. once
from `~/.eldev/config' and once from `Eldev').  However,
CONFIGURATION for all activations but the first will be ignored.

Since 0.3."
  (unless (assq plugin eldev--active-plugin-documentation)
    (push `(,plugin . ,(pcase plugin
                         (`autoloads  (eldev--autoloads-plugin  configuration))
                         (`undercover (eldev--undercover-plugin configuration))
                         (_ (error "Unknown plugin `%s'" plugin))))
          eldev--active-plugin-documentation)))



;; Autoloads.

(defvar eldev--collect-autoloads-from
  '(:and eldev-main-fileset
         ;; Have to duplicate `autoload' logic here.  I have no idea why it discards files
         ;; with `=' at the front, but we need to do the same to remain compatible with
         ;; installed packages.
         ("./*.el" "./*.el.gz" "!./.*" "!./=*")))

(defvar elisp-lint--autoloads-filename)

(defun eldev--autoloads-plugin (_configuration)
  "Plugin that enables processing of autoload cookies, generating
and updating file `PROJECT-autoloads.el' automatically.  Eldev
uses this file if present, so that commands like `test', `eval'
etc. can use function autoloading regardless of loading mode â€” it
works like in a real package.

If this plugin is active, a new virtual target `:autoloads' is
added to the tree.  It is built by default.  It collects forms
with preceding `;;;###autoload' cookie from all `.el' files in
the project's root.  This is exactly what is performed when a
package is installed by Emacs packaging system.  Before commands
`test', `eval' and the like are executed, Eldev makes sure that
the file is up-to-date.

It is recommended to instruct your VCS to ignore file
`PROJECT-autoloads.el', as it will be autogenerated.

When using a project with this plugin as a local dependency,
specify loading mode `built' (or `built-and-compiled',
`built-source'):

    (eldev-use-local-dependency \"...\" 'built)

Otherwise, autoloads file for the dependency may become
out-of-date."
  (eldev-defbuilder eldev-builder-autoloads (sources target)
    :type           many-to-one
    :short-name     "AUTOLOADS"
    :message        target
    :source-files   eldev--collect-autoloads-from
    :targets        (lambda (_sources)
                      (format "%s-autoloads.el" (package-desc-name (eldev-package-descriptor))))
    :define-cleaner (eldev-cleaner-autoloads
                     "Delete the generated package autoloads files."
                     :default t)
    :collect        (":default" ":autoloads")
    ;; To make sure that `update-directory-autoloads' doesn't grab files it shouldn't,
    ;; override `directory-files' temporarily.
    (eldev-advised (#'directory-files :around (lambda (original directory &rest arguments)
                                                (let ((files (apply original directory arguments)))
                                                  (if (file-equal-p directory eldev-project-dir)
                                                      (let (filtered)
                                                        (dolist (file files)
                                                          (when (eldev-any-p (file-equal-p file it) sources)
                                                            (push file filtered)))
                                                        (nreverse filtered))
                                                    files))))
      (let ((inhibit-message   t)
            (make-backup-files nil))
        (package-generate-autoloads (package-desc-name (eldev-package-descriptor)) eldev-project-dir)
        ;; Always load the generated file.  Maybe there are cases when we don't need that,
        ;; but most of the time we do.
        (eldev--load-autoloads-file (expand-file-name target eldev-project-dir)))))
  (add-hook 'eldev-before-loading-dependencies-hook
            (lambda (type _additional-sets)
              (when (and type (not (eq type 'load-only)))
                (eldev-with-verbosity-level-except 'quiet (#'eldev-load-project-dependencies #'eldev-load-extra-dependencies)
                  (eldev-build ":autoloads")))))
  (let* ((autoloads-el    (format "%s-autoloads.el" (package-desc-name (eldev-package-descriptor))))
         (as-dependencies `((depends-on ,autoloads-el))))
    (setf eldev-standard-excludes `(:or ,eldev-standard-excludes ,(format "./%s" autoloads-el)))
    ;; FIXME: Or maybe make this optional?  However, if autoloads file is already present,
    ;;        Eldev will use it, probably making this too confusing.
    (eldev-with-target-dependencies
      (dolist (el-file (eldev-find-files `(:and ,eldev--collect-autoloads-from "*.el")))
        (eldev-set-target-dependencies (concat el-file "c") 'eldev--autoloads-plugin as-dependencies)))
    ;; `elisp-lint' can generate autoloads itself.  Replace that with what we do.  As
    ;; always, there seems to be no other way than diving into internals.
    (with-eval-after-load 'elisp-lint
      (advice-add 'elisp-lint--generate-autoloads :override
                  (lambda (&rest _etc)
                    (eldev-with-verbosity-level-except 'quiet (#'eldev-load-project-dependencies #'eldev-load-extra-dependencies)
                      (eldev-build ":autoloads"))
                    (setf elisp-lint--autoloads-filename autoloads-el)))))
  (eldev-documentation 'eldev--autoloads-plugin))

(defun eldev--autoloads-used-p ()
  (eldev-any-p (with-temp-buffer
                 (insert-file-contents it)
                 (let ((case-fold-search nil))
                   (re-search-forward (rx bol (0+ space) ";;;###autoload" (0+ space) eol) nil t)))
               (eldev-find-files eldev--collect-autoloads-from)))



;; Undercover.

(defvar eldev-undercover-config nil
  "Configuration for `undercover' plugin as a list.
Each element should be a symbol matching one of the recognized
flags.  See function `eldev-undercover-config'.")

(defvar eldev-undercover-report-file nil
  "Filename used for `undercover' report.
If this is nil, value of `undercover--report-file-path' is
effectively not modified.")

(defvar eldev-undercover-fileset "*.el")

(defconst eldev--undercover-flags '(auto on off always never coveralls simplecov codecov text merge restart send dontsend safe force))


(defvar undercover-force-coverage)
(defvar undercover--report-file-path)
(defvar undercover--report-format)


(defun eldev--undercover-config (&optional plugin-configuration)
  (let (file
        mode
        format
        merge
        dontsend
        force)
    (dolist (flag (append plugin-configuration (eldev-listify eldev-undercover-config)))
      (eldev-pcase-exhaustive flag
        ((or `auto `on `off)                       (setf mode     flag))
        ((or `always `never)                       (setf mode     (if (eq flag 'always) 'on 'off)))
        ((or `coveralls `simplecov `codecov `text) (setf format   flag))
        ((or `merge `restart)                      (setf merge    (eq flag 'merge)))
        ((or `send `dontsend)                      (setf dontsend (eq flag 'dontsend)))
        ((or `safe `force)                         (setf force    (eq flag 'force)))
        ;; This is mostly for plugin configuration.
        ((pred stringp)                            (setf file flag))))
    (unless file
      (setf file eldev-undercover-report-file))
    (when eldev-dwim
      (when (and file (null format))
        (setf format (cond ((string-suffix-p ".json" file)                                    'simplecov)
                           ((or (string-suffix-p ".txt" file) (string-suffix-p ".text" file)) 'text))))
      (unless (or mode (memq format '(nil coveralls)))
        (setf mode 'on)))
    ;; Return value is a cons of two lists: a plist for internal use and for use as
    ;; `undercover' library's configuration.
    `((:mode ,(or mode 'auto) :merge ,merge :force ,force)
      . (,@(when file `((:report-file ,file))) (:report-format ',format) (:send-report ,(not dontsend))))))

(defun eldev--undercover-plugin (configuration)
  "Plugin that provides integration with `undercover' library,
generating test coverage reports for your project.  Even if the
plugin is active, it will not necessarily generate the report,
see below.

This plugin only activates if project's loading mode is `as-is',
`source' or `built-source', since the library cannot handle
byte-compiled files.  If the plugin decides to collect coverage
statistics in mode `as-is', Emacs will load source files even if
byte-compiled versions are available.

By default, it is up to `undercover' library to decide whether
and which report to generate.  Normally, it does so only on
supported continuous integration services.  However, you can use
option `--undercover' (`-u') of command `test' to easily change
this.  Value of the option must be a comma and/or space-separated
list of any of the following flags:

  - `auto' (default), `on' (or `always'), `off' (or `never'):
    whether to collect coverage statistics and generate a report;

  - `coveralls' (default), `simplecov', `codecov', `text': format
    of the generated report;

  - `merge' or `restart' (default): whether to merge with
    existing report file or delete it and create new report from
    scratch; simple text reports are never merged;

  - `send' (default), `dontsend': whether to upload the report to
    coveralls.io (only for `coveralls' format);

  - `safe' (default) or `force': whether to run `undercover' even
    if the plugin detects it likely won't work on this Emacs version
    (currently these options do nothing; they had been used
    before `undercover' 0.7 got released and are kept for
    compatibility and in case they get needed again in the
    future).

Most flags have their default value provided by `undercover'
library itself.  As of version 0.8 those are `coveralls' and
`send'.  However, defaults can also be changed in project's file
`Eldev'.

Additionally, option `--undercover-report' (`-U') lets you change
the report's filename.  Default value is controlled by the
library.

When `eldev-dwim' is non-nil (default), certain flags can affect
each other:

  - if report format is not set explicitly it is derived from
    extension of report filename if possible: `.json' for
    `simplecov' format, `.txt' or `.text' for a text report;

  - when requested format is not `coveralls', report is always
    generated unless `auto' or `off' (`never') is specified
    explicitly.

This special handling is aimed at reports created for local use,
i.e. usually in `simplecov' format.  Default values are normally
for coveralls.io and the report only gets generated on supported
continuous integration services."
  (add-hook 'eldev-test-hook (lambda () (eldev--set-up-undercover configuration)))
  (eldev-add-documentation-preprocessor 'eldev-test (lambda (documentation)
                                                      (concat documentation "\n\n"
                                                              (eldev-colorize "Plugin `undercover'" 'section) "\n\n"
                                                              (documentation 'eldev--undercover-test-doc t))))
  (eldev-defoption eldev-set-undercover-config (config)
    "Whether and how to use `undercover'"
    :options        (-u --undercover)
    :value          CONFIG
    :for-command    test
    (let (new-flags)
      (dolist (flag (split-string config "[, \t]" t "[ \t]+"))
        (unless (memq (setf flag (intern flag)) eldev--undercover-flags)
          (signal 'eldev-wrong-option-usage `("unknown flag `%s'" flag)))
        (push flag new-flags))
        (setf eldev-undercover-config (append (eldev-listify eldev-undercover-config) (nreverse new-flags)))))
  (eldev-defoption eldev-set-undercover-report-file (file)
    "Set `undercover's report filename"
    :options        (-U --undercover-report)
    :value          FILE
    :for-command    test
    (setf eldev-undercover-report-file file))
  (eldev-documentation 'eldev--undercover-plugin))

(defun eldev--undercover-test-doc ()
  "This plugin adds a runtime dependency on `undercover' package
and tells it which files to instrument.  By default, those are
all Elisp files in your `main' target set; change value of
variable `eldev-undercover-fileset' if needed.  See detailed
plugin documentation for more information."
  nil)

(defun eldev--set-up-undercover (configuration)
  (let* ((configuration (eldev--undercover-config configuration))
         (mode          (plist-get (car configuration) :mode)))
    (cond ((eq mode 'off)
           (eldev-trace "Disabled `undercover' coverage report generation"))
          ((not (memq eldev-project-loading-mode '(nil as-is source built-source)))
           ;; It looks like Emacs loads source files when they have load handlers, even if
           ;; there is `.elc' available.  However, let's still disable `undercover' when
           ;; any of the byte-compiling loading modes are requested: plugin is secondary
           ;; and shouldn't change the mode.  On the bright side, we don't need to care if
           ;; files are byte-compiled when using `as-is' mode with `undercover'.
           (if (eq mode 'on)
               (eldev-warn "Cannot collect coverage information from byte-compiled files; plugin `undercover' will not be enabled")
             (eldev-trace "Not activating plugin `undercover' since the project is in a byte-compiled loading mode")))
          (t
           (let ((files (eldev-find-and-trace-files '(:and (eldev-standard-filesets 'main) eldev-undercover-fileset) "file%s for `undercover' to instrument" 'dont-trace)))
             (when files
               (eldev-add-extra-dependencies 'runtime '(:tool undercover))
               (eldev-load-extra-dependencies 'runtime)
               (require 'undercover)
               (setf undercover-force-coverage (not (eq mode 'auto)))
               (eldev-trace (if undercover-force-coverage
                                "Forcing `undercover' to generate coverage report..."
                              "Leaving it up to `undercover' to decide whether to generate coverage report..."))
               ;; We already have a list of files, disable wildcard processing.
               (eldev-advised ('undercover--wildcards-to-files :override #'identity)
                 (eldev-advised ('undercover--edebug-files :before (lambda (files &rest _ignored)
                                                                     (eldev-verbose "Instrumenting %s for collecting coverage information with `undercover'"
                                                                                    (eldev-message-plural (length files) "file"))))
                   ;; Because `undercover-report' runs from `kill-emacs-hook', using
                   ;; `eldev-advised' here would not be enough.
                   (advice-add 'undercover-report :around (lambda (original &rest etc)
                                                            ;; Ugly, ugly, ugly: going deep into internals.
                                                            (let* ((report-format (when (boundp 'undercover--report-format) undercover--report-format))
                                                                   effective-report-name)
                                                              (when (boundp 'undercover--report-file-path)
                                                                (setf effective-report-name (or undercover--report-file-path
                                                                                                (pcase report-format
                                                                                                  (`coveralls "/tmp/undercover_coveralls_report")
                                                                                                  (`simplecov "coverage/.resultset.json")
                                                                                                  (`codecov   "coverage-final.json")))))
                                                              (when effective-report-name
                                                                (eldev-verbose "Saving `undercover' report to file `%s'..." effective-report-name)
                                                                ;; `undercover' will fail if file is in a non-existing directory.
                                                                (let ((dir (file-name-directory effective-report-name)))
                                                                  (when dir
                                                                    (make-directory dir t))))
                                                              (if (plist-get (car configuration) :merge)
                                                                  (eldev-trace "Code coverage report will be merged with existing")
                                                                (if effective-report-name
                                                                    (when (file-exists-p effective-report-name)
                                                                      (delete-file effective-report-name)
                                                                      (eldev-trace "Deleted previous code coverage report; new one will be restarted from scratch"))
                                                                  (unless (eq report-format 'text)
                                                                    (eldev-warn "Cannot determine where coverage report is generated; unable to honor `restart' flag"))))
                                                              (eldev-output-reroute-messages
                                                                (let ((eldev-message-rerouting-wrapper (unless (and (eq report-format 'text) (null effective-report-name))
                                                                                                         #'eldev-verbose)))
                                                                  (apply original etc))))))
                   ;; Since `undercover' is a macro, we have to do it like this.
                   (eval `(undercover ,@files ,@(cdr configuration)) t)))))))))


(provide 'eldev-plugins)
